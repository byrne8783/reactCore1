.xprog
___________________________
PropertyGroup block:

    <PropertyGroup>
         <TypeScriptCompileBlocked>true</TypeScriptCompileBlocked>
    </PropertyGroup>

    <ItemGroup>
        <Content Include="**\*.ts" Exclude="$(GlobalExclude)" />
    </ItemGroup>
`tsconfig.json` file to your project root and make sure the following setting is set:

    "compileOnSave": false,	
	
other stuff  to do with Microsoft.TypeScript.targets:
    <!-- Makes the TypeScript compilation task a no-op -->
    <TypeScriptCompileBlocked Condition="'$(TypeScriptCompileBlocked)' == ''">false</TypeScriptCompileBlocked>	
	
There should be a TypeScript Buils tab in my project properties, which when I set the bits might give me in my project file:
<TypeScriptTarget>ES5</TypeScriptTarget>
<TypeScriptJSXEmit>None</TypeScriptJSXEmit>
<TypeScriptModuleKind>ES6</TypeScriptModuleKind>
<TypeScriptCompileOnSaveEnabled>False</TypeScriptCompileOnSaveEnabled>
<TypeScriptNoImplicitAny>False</TypeScriptNoImplicitAny>
<TypeScriptRemoveComments>False</TypeScriptRemoveComments>
<TypeScriptOutFile />
<TypeScriptOutDir />
<TypeScriptGeneratesDeclarations>False</TypeScriptGeneratesDeclarations>
<TypeScriptNoEmitOnError>True</TypeScriptNoEmitOnError>
<TypeScriptSourceMap>True</TypeScriptSourceMap>
<TypeScriptMapRoot />
<TypeScriptSourceRoot />	

startup.cs
_____________________
if (env.IsDevelopment())
{
    app.UseWebpackDevMiddleware(new WebpackDevMiddlewareOptions {
        HotModuleReplacement = true,
        HotModuleReplacementClientOptions = new Dictionary<string, string> { 
            { "reload", "true" }, 
        },
        ConfigFile = "node_modules/@vue/cli-service/webpack.config.js",
    });
}

tsconfig.json`
_____________________
{
  "compileOnSave": false,
  "compilerOptions": {
    "module": "es2015",
    "moduleResolution": "node",
    "target": "es5",
    "sourceMap": true,
    "strict": true
  "lib": [
    "es6",
    "dom",
    "es5"
  ]	,
    "outDir": "./Scripts/out/",   // redirects output structure to this folder
    "rootDir": "./Scripts/src"  
  }
}

webpack.config.js
___________________________
{

    target: 'node',
    devtool: 'inline-source-map'
    module: {
        loaders: [
            { test: /\.ts$/, loader: 'ts-loader' }
        ]
    }

}

resources
________________________________
Interesting         https://docs.microsoft.com/en-us/aspnet/core/tutorials/signalr-typescript-webpack?view=aspnetcore-2.2&tabs=visual-studio
					https://dzone.com/articles/the-aspnet-core-react-project
					
Bits of client-side stuff
					https://docs.microsoft.com/en-us/aspnet/core/tutorials/signalr-typescript-webpack?view=aspnetcore-2.2&tabs=visual-studio
					
					https://github.com/aspnet/JavaScriptServices/tree/master/src/Microsoft.AspNetCore.SpaServices
					
Some guff about spinners 
____________________________________
$(document).ready(function() {
    $("#btnFetch").click(function() {
      // disable button
      $(this).prop("disabled", true);
      // add spinner to button
      $(this).html(
        `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>Loading...`
      );
    });
});

some promise stuff https://blog.jcore.com/2016/12/18/promise-me-you-wont-use-promise-race/
______________________________________________________________________________
Promise.properRace = function (promises: Array<Promise<ResponseGeneral>>, count = 1, results = []) {
    var promises: Array<Promise<ResponseGeneral>> = Array.from(promises);
    if (promises.length < count) { //must have enough contenders to finish
        return Promise.reject('Race is not finishable');
    }
    // There is no way to know which promise is resolved/rejected.
    // So we map it to a new promise to return the index.
    let indexPromises = promises.map((p, index) => p.then(() => index, () => { throw index; }));
    return Promise.race(indexPromises).then(index => {
        let p = promises.splice(index, 1)[0];         // The promise has resolved, remove it from the list of promises
        p.then(e => results.push(e));
        if (count === 1) {            
            return results; // The race has finished now
        }
        return Promise.properRace(promises, count - 1); // Continue the race, but now we expect one less winner because we have found one
    }, index => {
        // The promise has rejected, remove it from the list of promises and just 
        // continue the race without changing the count.
        promises.splice(index, 1);
        return Promise.properRace(promises, count);
    });
};